#include "hal_data.h"
#include "string.h"
#include "stdlib.h"
#include <time.h>

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
void CheckGroup();
void LED_Control();
void FND_Control();
void DC_Control();
void ADC_Control();
void DAC_Control();

void R_FND_Print_Data(uint8_t *string);
void R_FND_Display_Data(uint8_t digit, uint8_t data);
void FND_off();             //fnd turn off
void FND_DEC();
void FND_HEX();
void FND_BIN();

void IRQ_Setting();
void GPT_Setting();

void ADC_onoff();
void ADC1_read_convert();
void ADC2_read_convert();
void Cds_Sensor_Read();
void Potentiometer_Read();
void Thermal_Sensor_Read();
FSP_CPP_FOOTER

#define PODR_INDEX_HIGH       7
#define PODR_INDEX_LOW        4
#define PODR_DIGIT_MASK       0x01E0
#define PODR_HIGH_MASK        0x7800
#define PODR_LOW_MASK         0x00F0
#define PODR_PIN_MASK         PODR_HIGH_MASK | PODR_LOW_MASK
#define DATA_MAX_SIZE        50
#define STX                  0x02
#define ETX                  0x03
#define DIGIT_INDEX          4

uint8_t number[16] = {0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xD8, 0x80, 0x90, 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E};
uint8_t print_data[4] = {0xC0, 0xC0, 0xC0, 0xC0};
uint8_t data[10] = {0};
uint8_t adcdata[8] = {0};

bsp_io_port_pin_t L293_CH0_Enable = BSP_IO_PORT_09_PIN_00;
bsp_io_port_pin_t L293_CH0_Direction = BSP_IO_PORT_09_PIN_01;

uint8_t L293_CH0_Enable_Level = BSP_IO_LEVEL_LOW;
uint8_t L293_CH0_Direction_Level = BSP_IO_LEVEL_HIGH;

uint32_t Timer_Period = 0x249F00;
uint32_t dutyRate = 60;

uint16_t potentiometer_mV = 0, potentiometer_Ra = 0, potentiometer_Rb = 0, resistor_value = 0;
uint16_t temperature_mV; int16_t temperature;
uint16_t cds_data;
typedef enum {
    CDS_light = 1,
    CDS_dark = 0,
}CDS_t;

CDS_t brightness;

const float ADC_CONST = (float)(3.3/4096);

volatile uint8_t data_idx = 0;
volatile uint8_t led1_state = 0;
volatile uint8_t led2_state = 0;
volatile uint8_t led3_state = 0;
volatile uint8_t data_flag = 0;
volatile uint8_t count = 0;
volatile uint8_t adccount = 0;
volatile uint8_t adcmode = 0;
volatile uint8_t agt_counter = 0;
volatile uint8_t fndclk = 0;
volatile uint8_t adc_switch = 0;

extern unsigned char rawData1[192480];
extern unsigned char rawData2[190176];

bsp_io_port_pin_t fnd_segment_ledindex[7] = {
                                             BSP_IO_PORT_06_PIN_04,
                                             BSP_IO_PORT_06_PIN_05,
                                             BSP_IO_PORT_06_PIN_06,
                                             BSP_IO_PORT_06_PIN_07,
                                             BSP_IO_PORT_06_PIN_11,
                                             BSP_IO_PORT_06_PIN_12,
                                             BSP_IO_PORT_06_PIN_13
};

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    /* TODO: add your own code here */

    R_SCI_UART_Open(&g_uart0_ctrl, &g_uart0_cfg);
    IRQ_Setting();
    GPT_Setting();
    R_AGT_Open(&g_timer0_ctrl, &g_timer0_cfg);
    R_AGT_Start(&g_timer0_ctrl);

    while(true)
    {
        R_FND_Print_Data(print_data);

        if (adc_switch == 1)
        {
            if ((adcmode == 0) || (adcmode == 2))
            {
                ADC1_read_convert();                    //Variable Resistor, CDS Sensor
            }
            if (adcmode == 1)
            {
                ADC2_read_convert();                    //Thermal Sensor
            }
        }
    }

#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

void R_FND_Print_Data(uint8_t *string)
{
    uint8_t idx = 0;

    if (sizeof(string) != DIGIT_INDEX)
        return;

    for (idx = 0; idx < DIGIT_INDEX; idx++)
        R_FND_Display_Data(idx, string[idx]);
}

void R_FND_Display_Data(uint8_t digit, uint8_t fnddata)
{
    uint16_t high_nibble = (uint16_t)((fnddata << PODR_INDEX_HIGH) & PODR_HIGH_MASK);
    uint16_t low_nibble = (uint16_t)((fnddata << PODR_INDEX_LOW) & PODR_LOW_MASK);

    R_BSP_SoftwareDelay(10, BSP_DELAY_UNITS_MICROSECONDS);

    R_PORT3->PCNTR1_b.PODR = (uint16_t)((0x0010 << (1 + digit)) & PODR_DIGIT_MASK);
    R_PORT6->PCNTR1_b.PODR = high_nibble | low_nibble;
}

void user_uart_callback(uart_callback_args_t *p_args)
{
    if(p_args->event == UART_EVENT_RX_CHAR) // If SDR (Serial Data Register) is charged, this event (UART_EVENT_RX_CHAR) is occurred.
    {
        switch(p_args->data)
        {
            case STX:
                if(data_flag)
                    data[data_idx++]=(uint8_t)p_args->data;
                else
                {
                    memset(&data,0,sizeof(data));
                    data_idx=0;
                    data_flag=1;
                }
                break;
            case ETX:
                /* TODO: add your own code here */
                if(data_flag)
                {
                    data_flag=0;
                    CheckGroup();
                }                   //ETX -> Check Group Number
                break;

            default:
                data[data_idx++] = (char)p_args->data; // If Receive data Register is charged, take some data in byte.
                break;
        }
    }
}


void CheckGroup()                //Group 데이터에 따라 동작 구분
{
    if (data[0] == 0x30)
        LED_Control();

    if (data[0] == 0x31)
        FND_Control();

    if (data[0] == 0x34)
        DC_Control();

    if (data[0] == 0x35)
        ADC_Control();

    if (data[0] == 0x36)
        DAC_Control();
}

void LED_Control()
{
    if (data[4] == 0x30)                       //Data = 0, LED1 toggle
    {
        led1_state = !led1_state;
        if (led1_state)
        {
            R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_10_PIN_08, BSP_IO_LEVEL_LOW);
        }
        else
        {
            R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_10_PIN_08, BSP_IO_LEVEL_HIGH);
        }
    }

    if (data[4] == 0x31)                      //Data = 1, LED2 toggle
    {
        led2_state = !led2_state;
        if (led2_state)
        {
            R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_10_PIN_09, BSP_IO_LEVEL_LOW);
        }
        else
        {
            R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_10_PIN_09, BSP_IO_LEVEL_HIGH);
        }
    }
}

void FND_Control()
{
    if (data[2] == 0x30)                    //Cmd = 0, decimal
        FND_DEC();

    if (data[2] == 0x31)                    //Cmd = 1, hexadecimal
        FND_HEX();

    if (data[2] == 0x32)                    //Cmd = 2, binary
        FND_BIN();
}

void FND_DEC()
{
    uint8_t value = number[data[4] - 48];
    print_data[3] = value;
    R_FND_Print_Data(print_data);
}

void FND_HEX()
{
    if (data[4] - 48 <= 9)                  //Data가 0~9인 경우
    {
        uint8_t value = number[data[4] - 48];
        print_data[3] = value;
        R_FND_Print_Data(print_data);
    }
    else                                    //Data가 A~F인 경우
    {
        uint8_t value = number[data[4] - 55];
        print_data[3] = value;
        R_FND_Print_Data(print_data);
    }
}

void FND_BIN()
{
    int binnum = 8*(data[4]-48) + 4*(data[5]-48) + 2*(data[6]-48) + 1*(data[7]-48);         //binary number
    uint8_t value = number[binnum];
    print_data[3] = value;
    R_FND_Print_Data(print_data);
}

void IRQ_Setting()
{
    R_ICU_ExternalIrqOpen(&g_external_irq11_ctrl, &g_external_irq11_cfg);
    R_ICU_ExternalIrqOpen(&g_external_irq12_ctrl, &g_external_irq12_cfg);
    R_ICU_ExternalIrqOpen(&g_external_irq13_ctrl, &g_external_irq13_cfg);
    R_ICU_ExternalIrqOpen(&g_external_irq14_ctrl, &g_external_irq14_cfg);

    R_ICU_ExternalIrqEnable(&g_external_irq11_ctrl);
    R_ICU_ExternalIrqEnable(&g_external_irq12_ctrl);
    R_ICU_ExternalIrqEnable(&g_external_irq13_ctrl);
    R_ICU_ExternalIrqEnable(&g_external_irq14_ctrl);
}

void R_IRQ_Interrupt(external_irq_callback_args_t *p_args)
{
    switch(p_args->channel)
    {
        case 11:
            count += count;
            uint8_t irqdata[7] = {STX, 0x32, 0x31, 0x30, 0x31, count+48, ETX};
            R_SCI_UART_Write(&g_uart0_ctrl, (unsigned char*)irqdata, 7);
            break;

        case 12:
        {
            adccount++;

            if (adccount % 3 == 0)
            {
                adcmode = 0;                    //adcmode = 0, Variable Resistor
                print_data[2] = number[0];
            }

            if (adccount % 3 == 1)
            {
                adcmode = 1;                    //adcmode = 1, Thermal Sensor
                print_data[2] = number[1];
            }

            if (adccount % 3 == 2)
            {
                adcmode = 2;                    //adcmode = 2, Cds Sensor
                print_data[2] = number[2];
            }
            R_FND_Print_Data(print_data);

            ADC_onoff();
            break;
        }

        case 13:
            led3_state = !led3_state;
            if (led3_state)
            {
                R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_10_PIN_10, BSP_IO_LEVEL_LOW);
            }
            else
            {
                R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_10_PIN_10, BSP_IO_LEVEL_HIGH);
            }
            break;

        case 14:
            agt_counter = 0;
            print_data[0] = number[0];
            print_data[1] = number[0];

            void R_FND_Print_Data(print_data);

            break;
    }
}

void GPT_Setting()
{
    R_MSTP->MSTPCRD_b.MSTPD5 = 0U; // GPT32EH3 Module Stop State Cancel

    R_GPT3->GTCR_b.MD = 0U; // GPT32EH3 Count Mode Setting (Saw-wave PWM Mode)
    R_GPT3->GTCR_b.TPCS = 0U; // GPT32EH3 Clock Source Pre-scale Setting (PCLKD/1)

    R_GPT3->GTPR = Timer_Period - 1; // GPT32EH3 Counting Maximum Cycle Setting
    R_GPT3->GTCNT = 0; // GPT32EH3 Counter Initial Value Setting

    R_GPT3->GTIOR_b.GTIOA = 9U; // Compare Matching Output Control Setting
    R_GPT3->GTIOR_b.OAE = 1U; // GPIOCA Output Pin Enable

    R_GPT3->GTCCR[0] = Timer_Period / 2; // 50% Duty Rate (Compare Matching Value Setting)
}

void DC_Control()
{
    R_GPT3->GTCR_b.CST = 1U;

    if (data[2] == 0x30)                    //Cmd = 0, DC enable
    {
        L293_CH0_Enable_Level = BSP_IO_LEVEL_HIGH;
        R_IOPORT_PinWrite(&g_ioport_ctrl, L293_CH0_Enable, L293_CH0_Enable_Level);
    }

    if (data[2] == 0x31)                    //Cmd = 1, DC disable
    {
        L293_CH0_Enable_Level = BSP_IO_LEVEL_LOW;
        R_IOPORT_PinWrite(&g_ioport_ctrl, L293_CH0_Enable, L293_CH0_Enable_Level);
    }

    if (data[2] == 0x32)                    //Cmd = 2, speed high
    {
        if (L293_CH0_Direction_Level)       //정방향(CW)인 경우, speed high
        {
            dutyRate = 20;
            R_GPT3->GTCCR[0] = Timer_Period * dutyRate / 100;
        }
        else                                //역방향(CCW)인 경우, speed high
        {
            dutyRate = 80;
            R_GPT3->GTCCR[0] = Timer_Period * dutyRate / 100;
        }
    }

    if (data[2] == 0x33)                    //Cmd = 3, speed low
    {
        if (L293_CH0_Direction_Level)       //정방향(CW)인 경우, speed low
        {
            dutyRate = 60;
            R_GPT3->GTCCR[0] = Timer_Period * dutyRate / 100;
        }
        else                                //역방향(CCW)인 경우, speed low
        {
            dutyRate = 40;
            R_GPT3->GTCCR[0] = Timer_Period * dutyRate / 100;
        }
    }

    if (data[2] == 0x34)                    //Cmd = 5, CW
    {
        L293_CH0_Direction_Level = BSP_IO_LEVEL_HIGH;
        R_IOPORT_PinWrite(&g_ioport_ctrl, L293_CH0_Direction, L293_CH0_Direction_Level);

        if (dutyRate == 80)
        {
            dutyRate = 20;
            R_GPT3->GTCCR[0] = Timer_Period * dutyRate / 100;
        }
        if (dutyRate == 40)
        {
            dutyRate = 60;
            R_GPT3->GTCCR[0] = Timer_Period * dutyRate / 100;
        }
        if (dutyRate == 20)
            R_GPT3->GTCCR[0] = Timer_Period * dutyRate / 100;

        if (dutyRate == 60)
            R_GPT3->GTCCR[0] = Timer_Period * dutyRate / 100;
    }

    if (data[2] == 0x35)                    //Cmd = 6, CCW
    {
        L293_CH0_Direction_Level = BSP_IO_LEVEL_LOW;
        R_IOPORT_PinWrite(&g_ioport_ctrl, L293_CH0_Direction, L293_CH0_Direction_Level);

        if (dutyRate == 20)
        {
            dutyRate = 80;
            R_GPT3->GTCCR[0] = Timer_Period * dutyRate / 100;
        }
        if (dutyRate == 60)
        {
            dutyRate = 40;
            R_GPT3->GTCCR[0] = Timer_Period * dutyRate / 100;
        }
        if (dutyRate == 80)
            R_GPT3->GTCCR[0] = Timer_Period * dutyRate / 100;

        if (dutyRate == 40)
            R_GPT3->GTCCR[0] = Timer_Period * dutyRate / 100;
    }
}

void R_AGT0_Interrupt(timer_callback_args_t *p_args)
{
    FSP_PARAMETER_NOT_USED(p_args);

    fndclk++;

    if((fndclk % 2) == 1)                   // 1s마다 counter 증가
    {
        if (agt_counter == 99)
        {
            agt_counter = -1;
        }

        agt_counter++;

        print_data[0] = number[agt_counter/10];
        print_data[1] = number[agt_counter%10];

        R_FND_Print_Data(print_data);
    }

    if(adc_switch == 1)
    {
        if(adcmode == 0)                    //Variable Resistor
        {
            uint8_t adcdata[8] = {STX, 0x35, 0x31, 0x31, 0x32, 0x30, resistor_value , ETX};
            R_SCI_UART_Write(&g_uart0_ctrl, (unsigned char*)adcdata, 8);
            IRQ_Setting();
        }

        if (adcmode == 1)                   //Thermal Sensor
        {
            uint8_t adcdata[8] = {STX, 0x35, 0x31, 0x31, 0x32, 0x31, temperature , ETX};
            R_SCI_UART_Write(&g_uart0_ctrl, (unsigned char*)adcdata, 8);
            IRQ_Setting();
        }

        if (adcmode == 2)                   //CDS Sensor
        {
            uint8_t adcdata[8] = {STX, 0x35, 0x31, 0x31, 0x32, 0x32, brightness + 48, ETX};
            R_SCI_UART_Write(&g_uart0_ctrl, (unsigned char*)adcdata, 8);
            IRQ_Setting();
        }
    }
}

void ADC_Control()
{
    if (data[1] == 0x30)                    //Cmd class = 0
    {
        if(data[4] == 0x30)                 //data = 0, adc off
        {
           adc_switch = 0;
        }

        if (data[4] == 0x31)                //data = 1, adc on
        {
            adc_switch = 1;
            ADC_onoff();
        }
    }
}

void ADC_onoff()
{
    switch (adc_switch)                 //adc_switch : flag에 따라 구분
    {
        case 0:                         //adc off
        {
            R_ADC_Close(&g_adc0_ctrl);
            R_ADC_Close(&g_adc1_ctrl);
            break;
        }

        case 1:                         //adc on
        {
            if ((adcmode == 0) || (adcmode == 2))          //Variable Resistor or Cds Sensor
            {
                R_ADC_Close(&g_adc1_ctrl);
                R_ADC_Open(&g_adc0_ctrl, &g_adc0_cfg);
                R_ADC_ScanCfg(&g_adc0_ctrl, &g_adc0_channel_cfg);

            }
            if (adcmode == 1)                               //Thermal Sensor
            {
                R_ADC_Close(&g_adc0_ctrl);
                R_ADC_Open(&g_adc1_ctrl, &g_adc1_cfg);
                R_ADC_ScanCfg(&g_adc1_ctrl, &g_adc1_channel_cfg);
            }
            break;
        }
    }
}

void ADC1_read_convert()
{
    adc_status_t status;

    R_ADC_ScanStart(&g_adc0_ctrl);
    status.state = ADC_STATE_SCAN_IN_PROGRESS;
    while(ADC_STATE_SCAN_IN_PROGRESS == status.state)
    {
        R_ADC_StatusGet(&g_adc0_ctrl, &status);
    }
    Potentiometer_Read();
    Cds_Sensor_Read();
}

void ADC2_read_convert()
{
    adc_status_t status;

    R_ADC_ScanStart(&g_adc1_ctrl);
    status.state = ADC_STATE_SCAN_IN_PROGRESS;
    while(ADC_STATE_SCAN_IN_PROGRESS == status.state)
    {
        R_ADC_StatusGet(&g_adc1_ctrl, &status);
    }
    Thermal_Sensor_Read();
}

void Potentiometer_Read()
{
    uint16_t ch0_adc_result;

    R_ADC_Read(&g_adc0_ctrl, ADC_CHANNEL_0, &ch0_adc_result);
    potentiometer_mV = (uint16_t)(ch0_adc_result * ADC_CONST * 1000);
    potentiometer_Rb = (uint16_t)(potentiometer_mV * 3.0303);
    potentiometer_Ra = (uint16_t)(10000 - potentiometer_Rb);
    resistor_value = (uint16_t)(((float)potentiometer_Ra / 10000) * 100);                   //Ra의 값을 백분위로 변환
}

void Thermal_Sensor_Read()
{
    uint16_t ch1_adc_result;

    R_ADC_Read(&g_adc1_ctrl, ADC_CHANNEL_1, &ch1_adc_result);
    temperature_mV = (uint16_t)(ch1_adc_result * ADC_CONST * 1000);

    if(temperature_mV >= 500)
        temperature = (int16_t)((temperature_mV - 500) / 10);
    else
        temperature = (int16_t)((500 - temperature_mV) / 10);
}

void Cds_Sensor_Read()
{
    uint16_t ch2_adc_result;

    R_ADC_Read(&g_adc0_ctrl, ADC_CHANNEL_2, &ch2_adc_result);
    if(ch2_adc_result >= 400){
        cds_data = ch2_adc_result;
        brightness = CDS_dark;
    }
    else{
        cds_data = ch2_adc_result;
        brightness = CDS_light;
    }
}

void DAC_Control()
{
    R_DAC_Open(&g_dac0_ctrl, &g_dac0_cfg);
    R_DAC_Start(&g_dac0_ctrl);

    FND_off();                              //Sound 동작 중 FND off
    uint16_t value;

    if (data[4] == 0x31)
    {
        for(uint32_t i = 0; i < sizeof(rawData1); i += 2)
        {
            value = (uint16_t)(rawData1[i] | (rawData1[i + 1] << 8));
            R_DAC_Write(&g_dac0_ctrl, value);
            R_BSP_SoftwareDelay(20, BSP_DELAY_UNITS_MICROSECONDS);
        }
        R_BSP_SoftwareDelay(2, BSP_DELAY_UNITS_SECONDS);
    }

    if (data[4] == 0x32)
    {
        for(uint32_t i = 0; i < sizeof(rawData2); i += 2)
        {
            value = (uint16_t)(rawData2[i] | (rawData2[i + 1] << 8));
            R_DAC_Write(&g_dac0_ctrl, value);
            R_BSP_SoftwareDelay(20, BSP_DELAY_UNITS_MICROSECONDS);
        }
        R_BSP_SoftwareDelay(2, BSP_DELAY_UNITS_SECONDS);
    }
}

void FND_off()
{
    R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_03_PIN_05, BSP_IO_LEVEL_LOW);
    R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_03_PIN_06, BSP_IO_LEVEL_LOW);
    R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_03_PIN_07, BSP_IO_LEVEL_LOW);
    R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_03_PIN_08, BSP_IO_LEVEL_LOW);
}


/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&g_ioport_ctrl, g_ioport.p_cfg);
    }
}

#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif
