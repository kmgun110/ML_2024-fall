#include "hal_data.h"
#include "string.h"
#include "stdlib.h"
#include <stdlib.h>

#define NUM_FLOORS            4
#define DIGIT_INDEX           4
#define PODR_INDEX_HIGH       7
#define PODR_INDEX_LOW        4
#define PODR_DIGIT_MASK       0x01E0
#define PODR_HIGH_MASK        0x7800
#define PODR_LOW_MASK         0x00F0
#define PODR_PIN_MASK         PODR_HIGH_MASK | PODR_LOW_MASK
#define MAX_SERVO_DEGREE      180
#define MIN_SERVO_DEGREE      0
#define QUEUE_SIZE            100
#define STANDARD_CAN_FRAME    8

volatile int floor_queue[QUEUE_SIZE];
volatile int queue_head = 0;
volatile int queue_tail = 0;
volatile int agt_count = 0;
volatile int dc_count = 0;
volatile int sound_count = 0;
volatile int servo_count = 0;
volatile int floor_signal = 0;
volatile int sound_flag = 0;
volatile int can_flag = 0;
volatile const uint32_t Timer_Period_20ms = 0x249F00; // 20[ms] Duty Cycle (50[Hz])
volatile uint8_t system_flag = 0;
volatile uint8_t current_floor = 1;
volatile uint8_t target_floor = 1;
volatile uint8_t signal_value = 0;
const double SERVO_0_DUTY = 0.03;
const double SERVO_180_DUTY = 0.12;
const double EACH_SERVO_DEGREE = (SERVO_180_DUTY - SERVO_0_DUTY) / 180;
char state_flag;

extern unsigned char sound1[155616];

typedef enum {
    UP,
    IDLE,
    DOWN
} ElevatorDirection;

ElevatorDirection current_direction = IDLE;

typedef enum {
    OPEN,
    SET,
    CLOSE
} ServoRotate;

ServoRotate door = SET;

typedef enum
{
    STATE_IDLE,
    STATE_CONFIRM,
    STATE_RUN,
    STATE_STOP
} ElevatorState;

ElevatorState current_state = STATE_IDLE;

bsp_io_port_pin_t L293_CH0_Enable = BSP_IO_PORT_09_PIN_00;
bsp_io_port_pin_t L293_CH0_Direction = BSP_IO_PORT_09_PIN_01;

uint8_t L293_CH0_Enable_Level = BSP_IO_LEVEL_LOW;
uint8_t L293_CH0_Direction_Level = BSP_IO_LEVEL_HIGH;

uint32_t Timer_Period = 0x249F00;
uint32_t dutyRate = 50;

uint8_t number[4] = {0xF9, 0xA4, 0xB0, 0x99};
uint8_t print_data[4] = {0xBF, 0xF9, 0xF9, 0xBF};
uint8_t fnd1[6] = {0xFE, 0xDF, 0xEF, 0xF7, 0xFB, 0xFD};
uint8_t fnd4[6] = {0xFE, 0xFD, 0xFB, 0xF7, 0xEF, 0xDF};

bsp_io_port_pin_t fnd_segment_ledindex[7] = {
                                             BSP_IO_PORT_06_PIN_04,
                                             BSP_IO_PORT_06_PIN_05,
                                             BSP_IO_PORT_06_PIN_06,
                                             BSP_IO_PORT_06_PIN_07,
                                             BSP_IO_PORT_06_PIN_11,
                                             BSP_IO_PORT_06_PIN_12,
                                             BSP_IO_PORT_06_PIN_13
};

can_frame_t                         g_can_tx_frame;
can_frame_t                         g_can_rx_frame;

uint32_t id = 1U;

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
void R_FND_Print_Data(uint8_t *string);
void R_FND_Display_Data(uint8_t digit, uint8_t data);
void IRQ_Setting();
void GPT0_Setting();
void GPT3_Setting();
void Update_FND();
void Elevator_Idle();
void Elevator_Confirm();
void Elevator_Run();
void Elevator_Stop();
void Add_To_Queue(int floor);
void Control_LED(int floor, int signal);
void sort_queue();
void Confirm_State();
void Run_DC();
void Stop_DC();
void Run_Servo();
void sound_on();
void CAN_Frame_Setting(uint32_t id, uint8_t dlc, uint8_t *data);
void R_FND_Reset();
void Open_Servo();
void Close_Servo();
FSP_CPP_FOOTER


/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    /* TODO: add your own code here */

    IRQ_Setting();
    GPT0_Setting();
    GPT3_Setting();

    R_CAN_Open(&g_can0_ctrl, &g_can0_cfg);
    uint8_t data_field[] = "CAN OKAY";
    CAN_Frame_Setting(id, STANDARD_CAN_FRAME, data_field);
    R_CAN_Write(&g_can0_ctrl, 0, &g_can_tx_frame);

    R_DAC_Open(&g_dac0_ctrl, &g_dac0_cfg);
    R_DAC_Start(&g_dac0_ctrl);

    R_AGT_Open(&g_timer1_ctrl, &g_timer1_cfg);
    R_AGT_Start(&g_timer1_ctrl);

    while (1)
    {

        Update_FND();
        R_FND_Print_Data(print_data);

        switch (current_state)      //state machine
        {

            case STATE_IDLE:        //IDLE state
                Elevator_Idle();
                break;

            case STATE_CONFIRM:     //CONFIRM state
                Elevator_Confirm();
                break;

            case STATE_RUN:         //RUN state
                Elevator_Run();
                break;

            case STATE_STOP:        //STOP state
                Elevator_Stop();
                break;

            default:
                current_state = STATE_IDLE;
                signal_value = 0;
                break;
        }
    }


#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

void Elevator_Idle()
{
    current_direction = IDLE;
    IRQ_Setting();
    Update_FND();
    print_data[0] = 0xBF;
    print_data[3] = 0xBF;

    if(signal_value == 1)
    {
        current_state = STATE_CONFIRM;
    }
    else
        return;
}

void Elevator_Confirm()
{
    target_floor = floor_queue[queue_head];
    state_flag = 0;
    can_flag = 0;

    if (target_floor == 0)
    {
        target_floor = current_floor;
    }
    if (current_floor != target_floor)
    {
        dc_count = 0;
        current_state = STATE_RUN;
    }
    if (current_floor == target_floor)
    {
        current_state = STATE_STOP;
    }
}

void Elevator_Run()
{
    if (current_floor > target_floor)
    {
        current_direction = DOWN;
    }

    if(current_floor < target_floor)
    {
        current_direction = UP;
    }

    if (current_floor == target_floor)
    {
        current_direction = IDLE;
        current_state = STATE_STOP;
    }

    Run_DC();
}

void Elevator_Stop(void)
{
    current_direction = IDLE;

    Stop_DC();

    Update_FND();
    print_data[0] = 0xBF;
    print_data[3] = 0xBF;

    if(door == SET && sound_flag == 0)
    {
        sound_on();
    }
    if(door == OPEN)
    {
        Open_Servo();
    }
    if(door == CLOSE)
    {
        Close_Servo();
    }
    if(door == CLOSE && servo_count >= 20)                  //after sound, open, close -> reset
    {
        servo_count = 0;
        door = SET;
        Control_LED(target_floor, 0);
        current_state = STATE_IDLE;
        state_flag = 2;
    }

    if(state_flag == 2)                                     //reset target floor
    {
        for (int i = 0; i < queue_tail; i++)
        {
            floor_queue[i] = floor_queue[i + 1];
        }
        if(queue_tail > 0)
        {
            queue_tail = queue_tail - 1;
        }
        if (queue_head  == queue_tail)
        {
            signal_value = 0;
            IRQ_Setting();
        }
        state_flag = 3;
    }
}


void can_callback(can_callback_args_t *p_args)
{
    switch(p_args->event)
    {
        case CAN_EVENT_RX_COMPLETE:
            g_can_rx_frame = p_args->frame;
            memset(&(p_args->frame), 0, sizeof(can_frame_t));
            break;
        default:
            break;
    }
}

////////////////////////////////Switch////////////////////////////////////////////

void R_IRQ_Interrupt(external_irq_callback_args_t *p_args)
{
    switch(p_args->channel)
    {
        case 11:
            floor_signal = 1;
            Control_LED(1,1);
            break;

        case 12:
            floor_signal = 2;
            Control_LED(2,1);
            break;

        case 13:
            floor_signal = 3;
            Control_LED(3,1);
            break;

        case 14:
            floor_signal = 4;
            Control_LED(4,1);
            break;
    }

    Add_To_Queue(floor_signal);
    signal_value = 1;
}

void Add_To_Queue(int floor)                                 //enqueue new input
{
    if (floor < 1 || floor > 4)
        return;

    if (floor >= 1 && floor <= 4)
    {
        int next_tail = (queue_tail + 1) % QUEUE_SIZE;
        if (next_tail != queue_head)
        {
            floor_queue[queue_tail] = floor;
            queue_tail = next_tail;
        }
    }
    sort_queue();
}

void sort_queue()                                   //sort queue by direction, current floor
{
    int above_current[QUEUE_SIZE];
    int below_current[QUEUE_SIZE];
    int above_count = 0;
    int below_count = 0;

    int original_target_floor = target_floor;

    for (int i = queue_head; i != queue_tail; i = (i + 1) % QUEUE_SIZE)
    {
        if (floor_queue[i] > current_floor)                         //split the queue into two parts
        {
            above_current[above_count++] = floor_queue[i];
        }
        else
        {
            below_current[below_count++] = floor_queue[i];
        }
    }

    if (current_direction == UP)                                    //direction = up
    {
        for (int i = 0; i < above_count - 1; i++)                   //sort in ascending order
        {
            for (int j = i + 1; j < above_count; j++)
            {
                if (above_current[i] > above_current[j])
                {
                    int temp = above_current[i];
                    above_current[i] = above_current[j];
                    above_current[j] = temp;
                }
            }
        }

        for (int i = 0; i < below_count - 1; i++)                   //sort in descending order
        {
            for (int j = i + 1; j < below_count; j++)
            {
                if (below_current[i] < below_current[j])
                {
                    int temp = below_current[i];
                    below_current[i] = below_current[j];
                    below_current[j] = temp;
                }
            }
        }

        int idx = queue_head;                                       //merge queues
        for (int i = 0; i < above_count; i++)
        {
            floor_queue[idx] = above_current[i];
            idx = (idx + 1) % QUEUE_SIZE;
        }
        for (int i = 0; i < below_count; i++)
        {
            floor_queue[idx] = below_current[i];
            idx = (idx + 1) % QUEUE_SIZE;
        }
    }
    else if (current_direction == DOWN)                             //direction = down
    {
        for (int i = 0; i < below_count - 1; i++)                   //sort in descending order
        {
            for (int j = i + 1; j < below_count; j++)
            {
                if (below_current[i] < below_current[j])
                {
                    int temp = below_current[i];
                    below_current[i] = below_current[j];
                    below_current[j] = temp;
                }
            }
        }

        for (int i = 0; i < above_count - 1; i++)                   //sort in ascending order
        {
            for (int j = i + 1; j < above_count; j++)
            {
                if (above_current[i] > above_current[j])
                {
                    int temp = above_current[i];
                    above_current[i] = above_current[j];
                    above_current[j] = temp;
                }
            }
        }

        int idx = queue_head;                                       //merge queues
        for (int i = 0; i < below_count; i++)
        {
            floor_queue[idx] = below_current[i];
            idx = (idx + 1) % QUEUE_SIZE;
        }
        for (int i = 0; i < above_count; i++)
        {
            floor_queue[idx] = above_current[i];
            idx = (idx + 1) % QUEUE_SIZE;
        }
    }
    target_floor = floor_queue[queue_head];
    if (target_floor != original_target_floor)                    //if target floor changes, transmit can signal
    {
        state_flag = 0;
    }
}

//////////////////////////////////////////////////////////////////////////////


void Update_FND(void)
{
    print_data[1] = number[current_floor - 1];
    print_data[2] = number[target_floor - 1];
}

void Control_LED(int floor, int signal)
{
    if (signal == 1)
    {
        switch (floor)
        {
            case 1:
                R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_10_PIN_08, BSP_IO_LEVEL_LOW);
                break;

            case 2:
                R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_10_PIN_09, BSP_IO_LEVEL_LOW);
                break;

            case 3:
                R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_10_PIN_10, BSP_IO_LEVEL_LOW);
                break;

            case 4:
                R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_11_PIN_00, BSP_IO_LEVEL_LOW);
                break;
        }
    }
    else
    {
        switch (floor)
        {
            case 1:
                R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_10_PIN_08, BSP_IO_LEVEL_HIGH);
                break;

            case 2:
                R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_10_PIN_09, BSP_IO_LEVEL_HIGH);
                break;

            case 3:
                R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_10_PIN_10, BSP_IO_LEVEL_HIGH);
                break;

            case 4:
                R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_11_PIN_00, BSP_IO_LEVEL_HIGH);
                break;
        }
    }
}

////////////////////////////////////////RUN state////////////////////////////////

void Run_DC()
{

    if (state_flag == 0)
    {
        uint8_t data_field[10] = "MOVETO ";
        data_field[7] = target_floor + '0';
        CAN_Frame_Setting(id, STANDARD_CAN_FRAME, data_field);
        R_CAN_Write(&g_can0_ctrl, 0, &g_can_tx_frame);

        state_flag = 1;
    }

    R_GPT3->GTCR_b.CST = 1U;

    L293_CH0_Enable_Level = BSP_IO_LEVEL_HIGH;
    R_IOPORT_PinWrite(&g_ioport_ctrl, L293_CH0_Enable, L293_CH0_Enable_Level);

    if(current_direction == UP)
    {
        L293_CH0_Direction_Level = BSP_IO_LEVEL_HIGH;
        R_IOPORT_PinWrite(&g_ioport_ctrl, L293_CH0_Direction, L293_CH0_Direction_Level);
        R_GPT3->GTCCR[0] = Timer_Period * dutyRate / 100;
    }

    if(current_direction == DOWN)
    {
        L293_CH0_Direction_Level = BSP_IO_LEVEL_LOW;
        R_IOPORT_PinWrite(&g_ioport_ctrl, L293_CH0_Direction, L293_CH0_Direction_Level);
        R_GPT3->GTCCR[0] = Timer_Period * dutyRate / 100;
    }
}

/////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////STOP state//////////////////////////////////////
void Stop_DC()
{
    if(can_flag == 0)
    {
        uint8_t data_field[10] = "ARRITO ";
        data_field[7] = current_floor + '0';
        CAN_Frame_Setting(id, STANDARD_CAN_FRAME, data_field);
        R_CAN_Write(&g_can0_ctrl, 0, &g_can_tx_frame);
        can_flag = 1;
    }

    R_GPT3->GTCR_b.CST = 0U;
    L293_CH0_Enable_Level = BSP_IO_LEVEL_LOW;
    R_IOPORT_PinWrite(&g_ioport_ctrl, L293_CH0_Enable, L293_CH0_Enable_Level);
}

void sound_on()
{
    sound_count = 0;
    sound_flag = 1;

    for(uint32_t i = 0; i < sizeof(sound1); i += 2)
    {
        uint16_t value;
        value = (uint16_t)(sound1[i] | (sound1[i + 1] << 8));
        R_DAC_Write(&g_dac0_ctrl, value);
        R_BSP_SoftwareDelay(20, BSP_DELAY_UNITS_MICROSECONDS);
    }
}

void Open_Servo()
{
    Update_FND();
    print_data[0] = 0xBF;
    print_data[3] = 0xBF;

    R_GPT0->GTCR_b.CST = 1U;

    if (can_flag == 1)
    {
        uint8_t data_field[10] = "DR OPEN!";
        CAN_Frame_Setting(id, STANDARD_CAN_FRAME, data_field);
        R_CAN_Write(&g_can0_ctrl, 0, &g_can_tx_frame);
        can_flag = 2;
    }

    R_GPT0->GTCCR[0] = (uint32_t)(Timer_Period_20ms * SERVO_180_DUTY);
}

void Close_Servo()
{
    Update_FND();
    print_data[0] = 0xBF;
    print_data[3] = 0xBF;

    R_GPT0->GTCR_b.CST = 1U;

    if (can_flag == 2)
    {
        uint8_t data_field[10] = "DRCLOSE!";
        CAN_Frame_Setting(id, STANDARD_CAN_FRAME, data_field);
        R_CAN_Write(&g_can0_ctrl, 0, &g_can_tx_frame);
        can_flag = 0;
    }

    R_GPT0->GTCCR[0] = (uint32_t)(Timer_Period_20ms * SERVO_0_DUTY);
}

////////////////////////////////////////////////////////////////////////////////////

void R_AGT0_Interrupt(timer_callback_args_t *p_args)
{
    FSP_PARAMETER_NOT_USED(p_args);

    agt_count++;

    if(agt_count == 5)
    {
        agt_count = 0;
    }

    print_data[0] = fnd1[agt_count];
    print_data[3] = fnd4[agt_count];

    if(current_state == STATE_RUN)
    {
        dc_count++;

        if(dc_count >= 15)
        {
            dc_count = 0;

            if(current_direction == UP)
                current_floor++;
            if(current_direction == DOWN)
                current_floor--;
        }
    }

    if (sound_flag == 1)
    {
        sound_count ++;
    }

    if (sound_flag == 1 && sound_count >= 5)
    {
        sound_flag = 0;
        sound_count = 0;
        door = OPEN;
    }

    if (door == OPEN || door == CLOSE)
    {
        servo_count++;
    }

    if (door == OPEN && servo_count >= 15)
    {
        door = CLOSE;
    }

    Update_FND();
}

void R_FND_Print_Data(uint8_t *string)
{
    uint8_t idx = 0;

    if (sizeof(string) != DIGIT_INDEX)
        return;

    for (idx = 0; idx < DIGIT_INDEX; idx++)
        R_FND_Display_Data(idx, string[idx]);
}

void R_FND_Display_Data(uint8_t digit, uint8_t fnddata)
{
    uint16_t high_nibble = (uint16_t)((fnddata << PODR_INDEX_HIGH) & PODR_HIGH_MASK);
    uint16_t low_nibble = (uint16_t)((fnddata << PODR_INDEX_LOW) & PODR_LOW_MASK);

    R_BSP_SoftwareDelay(10, BSP_DELAY_UNITS_MICROSECONDS);
    R_FND_Reset();

    R_PORT3->PCNTR1_b.PODR = (uint16_t)((0x0010 << (1 + digit)) & PODR_DIGIT_MASK);
    R_PORT6->PCNTR1_b.PODR = high_nibble | low_nibble;
}

void R_FND_Reset()
{
    /* 7-Segment LED Pin State Initialization */
    R_PORT3->PCNTR1_b.PODR &= ~PODR_DIGIT_MASK & 0xFFFF;
    R_PORT6->PCNTR1_b.PODR |= PODR_PIN_MASK;
}

void GPT0_Setting()
{
    R_MSTP->MSTPCRD_b.MSTPD5 = 0U; // GPT32EH0 Module Stop State Cancel

    R_GPT0->GTCR_b.MD = 0U; // GPT32EH0 Count Mode Setting (Saw-wave PWM Mode)
    R_GPT0->GTCR_b.TPCS = 0U; // GPT32EH0 Clock Source Pre-scale Setting (PCLKD/1)

    R_GPT0->GTPR = Timer_Period - 1; // GPT32EH0 Counting Maximum Cycle Setting
    R_GPT0->GTCNT = 0; // GPT32EH0 Counter Initial Value Setting

    R_GPT0->GTIOR_b.GTIOA = 9U; // Compare Matching Output Control Setting
    R_GPT0->GTIOR_b.OAE = 1U; // GPIOCA Output Pin Enable

    R_GPT0->GTCCR[0] = (uint32_t)(Timer_Period * SERVO_0_DUTY); // GTCCR Initial Setting (Angle = 0[degree])
}

void GPT3_Setting()
{
    R_MSTP->MSTPCRD_b.MSTPD5 = 0U; // GPT32EH3 Module Stop State Cancel

    R_GPT3->GTCR_b.MD = 0U; // GPT32EH3 Count Mode Setting (Saw-wave PWM Mode)
    R_GPT3->GTCR_b.TPCS = 0U; // GPT32EH3 Clock Source Pre-scale Setting (PCLKD/1)

    R_GPT3->GTPR = Timer_Period - 1; // GPT32EH3 Counting Maximum Cycle Setting
    R_GPT3->GTCNT = 0; // GPT32EH3 Counter Initial Value Setting

    R_GPT3->GTIOR_b.GTIOA = 9U; // Compare Matching Output Control Setting
    R_GPT3->GTIOR_b.OAE = 1U; // GPIOCA Output Pin Enable
}

void IRQ_Setting()
{
    R_ICU_ExternalIrqOpen(&g_external_irq11_ctrl, &g_external_irq11_cfg);
    R_ICU_ExternalIrqOpen(&g_external_irq12_ctrl, &g_external_irq12_cfg);
    R_ICU_ExternalIrqOpen(&g_external_irq13_ctrl, &g_external_irq13_cfg);
    R_ICU_ExternalIrqOpen(&g_external_irq14_ctrl, &g_external_irq14_cfg);

    R_ICU_ExternalIrqEnable(&g_external_irq11_ctrl);
    R_ICU_ExternalIrqEnable(&g_external_irq12_ctrl);
    R_ICU_ExternalIrqEnable(&g_external_irq13_ctrl);
    R_ICU_ExternalIrqEnable(&g_external_irq14_ctrl);
}

void CAN_Frame_Setting(uint32_t id, uint8_t dlc, uint8_t *data)
{
    g_can_tx_frame.id = id;
    g_can_tx_frame.id_mode = CAN_ID_MODE_STANDARD;
    g_can_tx_frame.type = CAN_FRAME_TYPE_DATA;

    g_can_tx_frame.data_length_code = dlc;

    if (strlen((const char *)data) <= 8)
        memcpy(g_can_tx_frame.data, data, dlc);
    else
        memset(g_can_tx_frame.data, 0, sizeof(uint8_t) * STANDARD_CAN_FRAME);
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&g_ioport_ctrl, g_ioport.p_cfg);
    }
}

#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif
