#include "hal_data.h"
#include "stdlib.h"

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
void IRQ_Initial_Setting();
void IRQ_Enable();
void IRQ_Disable();
void Initial_Setting();
void LED_Reset();
void R_AGT1_Setting();
void R_GPT_Setting();
void R_GPT0_Setting();
void R_GPIO_Setting();
void R_AGT_Callback();
FSP_CPP_FOOTER

#define SEGMENT_INDEX               8
#define DIGIT_INDEX                 4
#define LED_INDEX                   4

#define AGT_ACCE_PERIOD             5
#define AGT_DECE_PERIOD             4
#define DUTY_RATE_UNIT              5

#define IO_PCNTR1_MASK              0x00010003

#define ANGLE_UNIT                  30
#define MAX_SERVO_DEGREE            180
#define MIN_SERVO_DEGREE            0
#define AGT_SERVO_PERIOD            (MAX_SERVO_DEGREE / ANGLE_UNIT)

volatile const uint8_t state_mask = 0x01;
volatile uint8_t led_state = 0;
volatile const uint32_t Timer_Period_20ms = 0x249F00; // 20[ms] Duty Cycle (50[Hz])
volatile uint8_t system_flag = 0;
static int current_angle = 0;



typedef enum _servo_state {
    SERVO_ROTATE_RIGHT = 0,
    SERVO_ROTATE_LEFT
} servo_state;

typedef struct _operation_state {
    volatile uint8_t task_mode_11;
    volatile uint8_t task_mode_12;
    volatile uint8_t task_mode_13;
    volatile uint8_t task_mode_14;
} operation_state;

volatile operation_state state;
volatile servo_state rotate_mode;
const double SERVO_0_DUTY = 0.03;
const double SERVO_30_DUTY = 0.045;

double temp_calc = 0.0;


static const bsp_io_port_pin_t led_pin[4] = {
                                BSP_IO_PORT_10_PIN_08,
                                BSP_IO_PORT_10_PIN_09,
                                BSP_IO_PORT_10_PIN_10,
                                BSP_IO_PORT_11_PIN_00
};
static const bsp_io_port_pin_t segment_digit[4] = {
                                      BSP_IO_PORT_03_PIN_05,
                                      BSP_IO_PORT_03_PIN_06,
                                      BSP_IO_PORT_03_PIN_07,
                                      BSP_IO_PORT_03_PIN_08
};
static const bsp_io_port_pin_t segment_led_pin[8] = {
                                           BSP_IO_PORT_06_PIN_14,
                                           BSP_IO_PORT_06_PIN_04,
                                           BSP_IO_PORT_06_PIN_05,
                                           BSP_IO_PORT_06_PIN_06,
                                           BSP_IO_PORT_06_PIN_07,
                                           BSP_IO_PORT_06_PIN_11,
                                           BSP_IO_PORT_06_PIN_12,
                                           BSP_IO_PORT_06_PIN_13
};




/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    Initial_Setting();

    ////////////// YOU MUST EDIT ONLY HERE ABOUT Advanced Assignment ///////////////
    R_GPT0->GTCR_b.CST = 1U;


    while(1);

    ///////////////////////////////////////////////////////////////////////////


#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}


//////////////////////////////// Timer Setting Function //////////////////////////////////////
void R_GPT_Setting()
{
    R_MSTP->MSTPCRD_b.MSTPD5 = 0U; // GPT32EHx (x=0 to 3) Module Stop State Cancel

    R_PMISC->PWPR_b.B0WI = (uint8_t)0U; // PFSWE Bit Write Protection Disable
    R_PMISC->PWPR_b.PFSWE = (uint8_t)1U; // PmnPFS Register Write Protection Disable

    R_PFS->PORT[4].PIN[15].PmnPFS_b.PMR = 1U; // GTIOC0A Pin Peripheral Function Enable
    R_PFS->PORT[4].PIN[15].PmnPFS_b.PSEL = 3U; // Port m/n Pin Function Select: GTIOC0A (GPT0 PWM Output)

    R_GPT0_Setting();

}


void R_GPT0_Setting() // Servo Motor PWM Generator
{
    R_GPT0->GTCR_b.MD = 0U; // GPT32EH0 Count Mode Setting (Saw-wave PWM Mode)
    R_GPT0->GTCR_b.TPCS = 0U; // GPT32EH0 Clock Source Prescale Setting (PCLKD/1)

    R_GPT0->GTPR = Timer_Period_20ms - 1; // GPT32EH0 Counting Maximum Cycle Setting
    R_GPT0->GTCNT = 0; // GPT32EH0 Counter Initial Value Setting

    ////////////// YOU MUST EDIT ONLY HERE ABOUT Advanced Assignment ///////////////

    R_GPT0->GTIOR_b.GTIOA = 9U;
    R_GPT0->GTIOR_b.OAE = 1U;

    R_GPT0->GTCCR[0] = (uint32_t)(Timer_Period_20ms * SERVO_0_DUTY);

    ///////////////////////////////////////////////////////////////////////////
}


void R_AGT1_Setting()
{
    R_MSTP->MSTPCRD_b.MSTPD2 = 0U; // AGT1 Module Stop State Cancel

    ////////////// YOU MUST EDIT ONLY HERE ABOUT Advanced Assignment ///////////////

    R_AGT1->AGTMR1 |= 0x41; // AGT1 Mode Register 1 Setting
    R_AGT1->AGTMR2 = 0x00; // AGT1 Mode Register 2 Setting
    R_AGT1->AGT = 0x199A;

    R_AGT_Start(&g_timer1_ctrl);
    ///////////////////////////////////////////////////////////////////////////
}

/////////////////////////////////////////////////////////////////////////////////


/// //////////////////////////////// Interrupt Setting Function //////////////////////////////////////

void R_IRQ14_ISR(external_irq_callback_args_t *p_args)
{
    FSP_PARAMETER_NOT_USED (p_args);
    ////////////// YOU MUST EDIT ONLY HERE ABOUT Advanced Assignment ///////////////
    R_IOPORT_PinWrite(&g_ioport_ctrl, led_pin[3], BSP_IO_LEVEL_LOW);

    system_flag = 1;

    rotate_mode = SERVO_ROTATE_RIGHT;


    ///////////////////////////////////////////////////////////////////////////
}


void R_AGT_Callback(timer_callback_args_t *p_args)
{
    FSP_PARAMETER_NOT_USED(p_args);
    
    ////////////// YOU MUST EDIT ONLY HERE ABOUT Advanced Assignment ///////////////
    // Use register to enable AGT1 interrupt
    if(system_flag == 0)
    {
        return;
    }
    R_GPT0->GTCR_b.CST = 1U;

    if (rotate_mode == SERVO_ROTATE_RIGHT)
    {
        current_angle += ANGLE_UNIT;

        if(current_angle >= MAX_SERVO_DEGREE)
        {
            current_angle = MAX_SERVO_DEGREE;
            rotate_mode = SERVO_ROTATE_LEFT;
        }
    }
    else if (rotate_mode == SERVO_ROTATE_LEFT)
    {
        current_angle -= ANGLE_UNIT;

        if (current_angle <= MIN_SERVO_DEGREE)
        {
            current_angle = MIN_SERVO_DEGREE;
            R_IOPORT_PinWrite(&g_ioport_ctrl, led_pin[3], BSP_IO_LEVEL_HIGH);
        }
    }


    double duty_cycle = SERVO_0_DUTY + ((double)current_angle / MAX_SERVO_DEGREE) * (SERVO_30_DUTY-SERVO_0_DUTY);
    R_GPT0->GTCCR[0] = (uint32_t)(Timer_Period_20ms*duty_cycle);
}
        ///////////////////////////////////////////////////////////////////////////


void R_GPIO_Setting()
{
    R_PORT9->PCNTR1 |= IO_PCNTR1_MASK;

    R_PORT10->PCNTR1_b.PDR |= 0x0700;
    R_PORT11->PCNTR1_b.PDR |= 0x0001;

    LED_Reset();
}

void LED_Reset()
{
    uint8_t idx = 0;

    /* LED Initialization */
    for (idx = 0; idx < LED_INDEX; idx++)
        R_IOPORT_PinWrite(&g_ioport_ctrl, led_pin[idx], BSP_IO_LEVEL_HIGH);
}


void Initial_Setting()
{
    state.task_mode_14 = 0;
    R_GPIO_Setting();
    IRQ_Initial_Setting();
    R_AGT1_Setting();
    R_GPT_Setting();
}

void IRQ_Initial_Setting()
{
    // Interrupt ICU Setting
    R_ICU_ExternalIrqOpen(&g_external_irq14_ctrl, &g_external_irq14_cfg); // enable switch 4
    R_AGT_Open(&g_timer1_ctrl, &g_timer1_cfg);                             // enable AGT 1
    IRQ_Enable();
}

void IRQ_Enable()
{
    // Interrupt Set Enable Register Setting (Enable)
    R_ICU_ExternalIrqEnable(&g_external_irq14_ctrl);
    
    ////////////// YOU MUST EDIT ONLY HERE ABOUT Advanced Assignment ///////////////
    // Use register to enable only (switch 4) interrupt

    R_ICU_ExternalIrqOpen(&g_external_irq14_ctrl, &g_external_irq14_cfg);

    NVIC->ISER[0] |= (uint32_t)0x01; // NVIC Interrupt Set-Enable Register Setting (Using Exception Number)

    R_ICU->IELSR_b[0].IELS = (uint32_t)0x0F; // ICU Event Link Select (Refer to the Table 14.4)

    R_PMISC->PWPR_b.B0WI = (uint8_t)0U;
    R_PMISC->PWPR_b.PFSWE = (uint8_t)1U;

    R_PFS->PORT[0].PIN[10].PmnPFS_HA_b.ISEL = (uint16_t)1U;
}





    ///////////////////////////////////////////////////////////////////////////

void IRQ_Disable()
{
    // Interrupt Set Disable Register Setting (Disable)

    R_ICU_ExternalIrqDisable(&g_external_irq14_ctrl);
}





/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&g_ioport_ctrl, g_ioport.p_cfg);
    }
}

#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif
